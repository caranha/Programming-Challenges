\documentclass{beamer}
\input{../tools/beamerpreamble.tex}

\title[GB21802]{GB21802 - Programming Challenges}
\subtitle[]{Week 1 - Data Structures}
\author[Claus Aranha]{Claus Aranha\\{\footnotesize caranha@cs.tsukuba.ac.jp}}
\institute{College of Information Science}
\date{2015-04-22,25\\{\tiny Last updated \today}}

\begin{document}

\section{Introduction}
\subsection{Title}
\begin{frame}
\maketitle
\end{frame}

\subsection{Notes and Warnings}

\begin{frame}
  \frametitle{Summary for Week 0}
  \begin{itemize}
  \item How the course works;
  \item How to solve simple (ad-hoc) programming challenges;
  \item Four simple programming challenges;
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Results for Week 0}
  \begin{tabular}{l|l|l|l|}
    Problem & Total& Submissions & Solutions\\
    \hline
    Division of Nlogonia & 31 & 27 & 27\\
    Cancer or Scorpio & 31 & 25 & 19 \\
    3n+1 Problem & 31 & 23 & 21 \\
    Request for Proposal & 31 & 18 & 13\\
    \hline
  \end{tabular}

  \bigskip
  \begin{center}
    Congratulations to all who submitted!

    \smallskip

    The problems for this week are already online.
  \end{center}
\end{frame}


\begin{frame}
  \frametitle{Outline for Week 1}

  \begin{block}{Week Theme: Data Structures}
  This week, we will review and discuss the different data structures that
  are often used in competitive programming problems.
  \end{block}

  \vfill

  \begin{itemize}
  \item Types and Variations of Data Structures (Linear 2D, 3D, Dynamic, Non-linear)
  \item Discussion on Implementation and notes;
  \item Discussion about next week exercises;
  \item Bitmasks (Monday?)
  \end{itemize}
\end{frame}


% Motivation to learn data structures
%% 8-queens example last week
%% Towers of hanoi example
%% Another example (Maybe File Fragmentation? -- maybe do this next week?)
\subsection{motivation}

\begin{frame}
  \frametitle{Motivation: Why study data structures?}

  \begin{itemize}
  \item The correct data structure makes the algorithm \structure{faster;}
    \smallskip
    {\small \emph{Example:} As we saw last week, the solution space of the 
      8-queen problem depends on the chosen structure.}

    \vspace{2em}

  \item A good \structure{implementation} of a data structure
    makes the implementation easier;

    \smallskip
    {\small \emph{Exemple:} Using a linked list, you raise the possibility of 
      null pointer errors.}
  \end{itemize}

  \begin{center}
    \includegraphics[width=0.8\textwidth]{../img/pipeline}
  \end{center}
  
\end{frame}

%% 8-queens example last week
%% Towers of hanoi example

\begin{frame}
  \frametitle{Example 1: 8 Queen Problem (UVA 750)}
  \includegraphics[width=.25\textwidth]{../img/8queen}\\
  Given the initial position of one queen, how many correct solutions exist?
  
  \begin{itemize}
  \item X,Y position representation = $58^8$ total solutions
  \item Column position representation = $8^8$ total solutions
  \item Permutation representation = $8!$ total solutions
  \end{itemize}


  \hrulefill\\
  {\tiny\hfill Image by Lee Daniel Crocker. CC-BY-SA 3.0}
\end{frame}

\begin{frame}
  \frametitle{Example 2: The Towers of Hanoi}
  
  \begin{center}
    \includegraphics[width=0.5\textwidth]{img/hanoi}
  \end{center}
  \medskip

  {\small
    \begin{itemize}
    \item You have $N$ disks and $K$ poles. Each disk has unique size $s_i$.
    \item A disk $i$ can be moved from one pole to another.
    \item A move of disk $i$ to pole $k$ is only valid if $k$ has no disks smaller than $i$
    \item Find the list of moves to move all disks from pole 1 to pole $K$.
    \end{itemize}
  }
  
  \vfill

  How do you represent the data in this problem?
\end{frame}

\begin{frame}
  \frametitle{Another way to visualize the Towers of Hanoi}
  \begin{center}
    \includegraphics[width=0.7\textwidth]{img/hanoi_graph}
  \end{center}
  {\tiny \hfill Image created by nonenmac}
\end{frame}

\begin{frame}
  \frametitle{Explaining the Tower of Hanoi Data Structure}
  \begin{columns}[c]
    \column{0.7\textwidth}
    \begin{itemize}
    \item Each node identifies an state in the problem;
    \item Each character in the string represents one disk and its
      position;
    \item We can have at most 3 state transitions at each state (can
      you prove it?)
    \item To solve the Towers of Hanoi problem, we find the path
      between the start and end states.
    \item (just beware of state explosion)
    \end{itemize}
    \column{0.3\textwidth}    
    \includegraphics[width=0.9\textwidth]{img/hanoi_graph}
    \vfill
  \end{columns}
\end{frame}

\section{Data Structures}
\subsection{Basics}
\begin{frame}
  \frametitle{What are data structures?}

  A data Structure (DS) is a mean of \structure{storing} and
  \structure{organizing} data. 

  \vfill

  Different Data structures have different strengths. You need to have
  a general idea of those, in order to \structure{select} and
  \structure{use} the right DS for the right problem.
\end{frame}

\begin{frame}
  \frametitle{What do you need to know about DS?}
  % What do you need to know about Data Structures?
  % Space and time complexity (insertion/removal)
  % Special Attributes
  % VERY IMPORTANT: how to implement them (sometimes just calling the correct library)
  \begin{block}{Characteristics of DS}
    \begin{itemize}
    \item Time Complexity: Insertion, Removal, Initialization, Access;
    \item Space Complexity: Repetitions of data, Empty Space;
    \item Others: Restrictions, Special behaviors;
    \end{itemize}
  \end{block}

  \begin{exampleblock}{Usage of DS}
    \begin{itemize}
    \item Is the DS in the STL or Java API? How to call it?
    \item If not, how to implement the DS?
    \item How to perform basic operations on the DS? (Modification/Sort/Search)
    \end{itemize}
  \end{exampleblock}
  
  {\small As you learn new things, don't forget to expand your library}
\end{frame}


\begin{frame}
  \frametitle{CAVEAT: When theory is important}
  % Caveat: Usage vs Theory
  % TODO: Improve this frame
  When solving programming challenges, we will normally focus more on
  the practical aspects of Data Structures (how fast it is? how to use
  it?). It is not important to us to understant WHY they work as they do.

  \bigskip

  However, for a well rounded scientist, it is important to know both
  the practical and theoretical aspects of many techniques.
\end{frame}

\subsection{Data Structure Operations}
\begin{frame}
  \frametitle{Linear Data Structures} 
  %% Important for programming contests.
  % Linear Data structure
  %% Static Array, Dynamic Array

  {\small
  One of the most common DS used in Programming Contests are. 

  \begin{block}{Linear Data Structures}
    The elements can be ordered in a linear sequence:\\
    left to right, top to down (Including multiple dimensions).
  \end{block}

  \begin{itemize}
  \item \structure{Static Array:} 
    \begin{itemize} 
    \item The size is fixed, or estimated in advance. 
    \item Native data types. Make them bigger than necessary!
    \end{itemize}
    
  \item \structure{Dynamic Array:}
    \begin{itemize}
    \item C++ STL vector / Java ArrayList;
    \item Number of elements is truly unknown;
    \item Learn how to use .iterators!
    \end{itemize}
  \end{itemize}
  }
\end{frame}

\begin{frame}
  \frametitle{Specialized Linear DSs}
  %% TODO: Add some problem examples for this slide.
  \begin{itemize}
  \item \structure{Array of Booleans (C++ bitset)}:\\
    Useful operations such as reset, set (initialization) and test (bounded access)
  \item \structure{Stack (C++ stack/Java stack)}:\\
    O(1) push and pop. Used for recursion/Postfix/Bracket matching
  \item \structure{Queue (C++ queue)}:\\
    push (to back), pop (from front), used for Breadth First Search, Topological Sorting
  \item \structure{Deque (C++ deque)}:\\
    push and pop from both ends. Used for ``sliding window'' algorithms.
  \end{itemize}
\end{frame}

% TODO: 2D arrays: usually an array of array (unless it is a
% matrix/table problems, which will be seen later)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sorting}
\subsection{Operations in Data Structures}

\begin{frame}
  \frametitle{Main operations in Arrays}

  When discussing linear DS, it is important to discuss two common
  actions done on them:

  \bigskip

  \begin{itemize}
    \item \structure{Sorting} -- Changing the position of items in the
      array according to some ordering.

      \bigskip

    \item \structure{Searching} -- Finding an item in an array with a
      certain value.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Actions on Linear DS -- Sorting}
  %% Give unsorted stuff, sort them
  %% For programming challenges, Sorting is usually a pre-liminary step for another problem
  \begin{block}{Super formal Definition}
    \hfill Given unsorted stuff, sort them!
  \end{block}

  \bigskip

  In programming contests, sorting is usually a preliminary step:
  \begin{itemize}
  \item sort a list to facilitate searching;
  \item sort a list to find highest values;
  \item sort a list for a greedy algorithm;
  \item sort a list to calculate cumulative values;
  \item etc...
  \end{itemize}
\end{frame}

\begin{frame}[fragile,singleslide]
  \frametitle{Sorting Example -- Vito's Family (UVA 10041)}
  
  \begin{exampleblock}{Problem description}
    A gangster wants to move to a new house. The new house should have
    minimal distance from all his family, who live on the same street.
  \end{exampleblock}

  \medskip

  This program can be summarized as ``find the median of the addresses
  and calculate the distance to all the houses.''

  \medskip

  \begin{block}{}
    {\small
\begin{verbatim}
for (i = 0; i < m; i++)
{
  cin >> add[i];
} 
sort(add,add+m);
med = add[(m/2)];
\end{verbatim}}
  \end{block}
\end{frame}


% TODO: Add this frame
%\begin{frame}
%  \frametitle{Other uses for sorting}
%  
%
%% Or maybe we want to ``beautify'' some output (eg. Return the first lexographical solution)
%\end{frame}


\begin{frame}
  \frametitle{Sorting algorithms}

  You probably have heard of a large number of sorting algorithms:

  \bigskip

  \begin{itemize}
    \item \structure{$O(n^2)$ algorithms:} Bubble, Selection, Insertion sort;
    \item \structure{$O(n\text{log}n)$ algorithms:} Merge/Heap/Quicksort;
    \item \structure{$O(n)$ algorithms}: Bucket/Radix sort;
  \end{itemize}

  \smallskip

  Can you remember the main characteristics of these algorithms?

%% Many algorithms, O(n^2), O(nlogn), Special purpose algorithms, In place, not in place

%% Huge list of sorting algorithms

%% For ICPC, you usually just need: O(nlogn) algorithm which is implemented on the library
%% Collections.sort, algorithm::sort
\end{frame}

\begin{frame}
  \frametitle{How many sorting Algorithms are there?}
  \begin{columns}[c]
    \column{0.5\textwidth}
    {\tiny
    \begin{itemize}
    \item bubblesort
    \item insertion sort
    \item selection sort
    \item heapsort
    \item mergesort
    \item quicksort
    \item radix sort
    \item bin sort
    \item gnome sort
    \item library sort
    \item comb sort
    \item tree transversal
    \item sorting networks
    \item cocktail shaking sort
    \item bucket sort
    \item bogo sort
    \item bitonick sort
    \item ...
    \item And many more!
    \end{itemize}}
    \column{0.5\textwidth}
    \includegraphics<2>[width=1\textwidth]{../img/fliptable}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Implementing Sorting} 

  {\small 
    You don't need to know every one of those methods. At least for
    programming contest, you need a good idea of how to use sorting in
    your language's API

    \medskip
    
  %% For ICPC, you usually just need: O(nlogn) algorithm which is implemented on the library
  %% Collections.sort, algorithm::sort
  \begin{block}{C++}
    Sorting is implemented by \emph{STL algorithm}.\\
    Eg: sort(memory\_start,memory\_end,function)\\
    See also partial\_sort() and stable\_sort()
  \end{block}
  \begin{block}{Java}
    To sort with Java we use ``Collections.sort(array,function)''    
  \end{block}
  }
\end{frame}

\begin{frame}
  %TODO: improve the ``Relax slides'' -- 2016, Class 1A ended here
  \frametitle{Relax time}
  \begin{enumerate}
  \item The song of the sorting people;
    \vfill
  \item The quantum bogosort;
  \end{enumerate}
\end{frame}

\section{Searching}
\subsection{Class 1B Start}
\begin{frame}
  \maketitle
  \begin{exampleblock}{}
    \begin{center}
      Class 1B (Searching, Non linear data structures, Bitmasking)
    \end{center}
  \end{exampleblock}
\end{frame}

\begin{frame}
  %% TODO: 2017: Update this slides for the new problems
  \frametitle{Talking about the problems}
  {\smaller
  \alert{Week 0}: Don't forget to send the source code to Manaba\\
  (Almost everyone did this already)

  \smallskip
  
  \alert{Week 1}: Don't forget that the deadline is this week!\\
  (I want you to rest during GW)
  }
  \medskip

  \begin{center}
    \includegraphics[width=0.7\textwidth]{../img/week1results2016}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Jolly Jumpers}
  Test a ``jolly'' sequence.
  \begin{itemize}
  \item Extremely easy problem, if you convert the input correctly;
  \item What information do we actually need from the input?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Army Buddies}
  Simulate changes in the data.
  \begin{itemize}
  \item Similar idea to Jolly Jumpers, but different data structure.
  \item What information do we need to store?
  \item What information do we need to \structure{change}?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Rotated Square}
  Count the number of patterns.
  \begin{itemize}
  \item ``bothersome'' problem.
  \item What data to store?
  \item What is the program structure?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{File Fragmentation}
  Find the original bit string.
  \begin{itemize}
  \item Understanding the problem: What are looking for here?
  \item Finding out the correct combination:
    \begin{itemize}
    \item Method1: Elimination;
    \item Method2: Counting;
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Contest Scoreboard}
  Output winning teams in a competition.
  \begin{itemize}
  \item Actually the second easiest problem of the week. Make sure to
    read all problems once before starting!
  \item Problem is about sorting multiple categories.
    \begin{itemize}
    \item You could create a single sort function to test all categories
    \item Or you could sort the data multiple times (sort must be stable!)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Multitasking}
  Given a list of time intervals, find out if they overlap.
  \begin{itemize}
  \item Simple, but long problem
  \item First: Imagine the solution
  \item Second: What kind of dataset do you need?
  \item Caution 1: unecessary loops!
  \item Caution 2: interval ends \alert{may} overlap;
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Jollybee Tournament}
  Calculate the number of WO matches.
  \begin{itemize}
  \item Is the number of WO matches equal to the number of missing players?
  \item Does it matter who wins?
  \item Can we represent the problem in a non-tree, iterative manner?
    \begin{itemize}
    \item Can we do it without iterating over each pair?
    \end{itemize}
  \end{itemize}
\end{frame}


\subsection{Searching in An Array}
\begin{frame}
  \frametitle{Searching in an array}

  \begin{block}{Finding the highest value}
    \begin{itemize}
    \item Unsorted array: $O(n)$
    \item Sorted array: $O(nlogn + 1)$
    \end{itemize}
    What if we need to repeat the operation $k$ times?
  \end{block}

  \begin{block}{Finding a specific value}
    \begin{itemize}
    \item Unsorted array: $O(n)$
    \item Sorted array: $O(n\text{log}n + \text{log}n)$ -- binary search!
    \end{itemize}
  \end{block}

  But can you implement a sorted array quickly?
\end{frame}



\begin{frame}[fragile,singleframe]
  \frametitle{Binary Search in C++}
  
  {\small You can use algorithm::lower\_bound and algorithm::upper\_bound
  
 
  \begin{block}{}
\begin{verbatim} 
#include <iostream>     
#include <algorithm>    
#include <vector>       
int main () {
  int myints[] = {10,20,30,30,20,10,10,20};
  std::vector<int> v(myints,myints+8);           
  std::sort (v.begin(), v.end());                

  std::vector<int>::iterator low,up;
  low=std::lower_bound (v.begin(), v.end(), 20); 
  up= std::upper_bound (v.begin(), v.end(), 20); 

  std::cout << "lower at " << (low- v.begin()) << '\n';
  std::cout << "upper at " << (up - v.begin()) << '\n';

  return 0; // up and low are memory indexes.
}
\end{verbatim}
    \end{block}
}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Non Linear Data Structures}
\begin{frame}
  \frametitle{Non Linear Data Structures}

  \begin{block}{Balanced Binary Search Tree}
    \begin{itemize}
    \item C++ Map/Set (implemented as RB tree)
    \item Java TreeMap/TreeSet
    \end{itemize}
    Access/Deletion/Search in $O(\text{log}n)$.
  \end{block}

  \begin{block}{Heap}
    \begin{itemize}
      \item C++ priority\_queue
      \item Java PriorityQueue
    \end{itemize}
    Gets the highest value individual in $O(1)$
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Tree Linear Structures: Example Problem}
  \begin{block}{UVA 10226 -- Hardwood Species}
    Input is up to 1.000.000 trees, up to 10.000 types. Sort and
    output the speciation. Test cases are not limited.
  \end{block}
  
  \bigskip

  Because of the huge numbers, storing the trees in an array will not
  be enough.  We need a fast data structure to solve this problem in
  time.

  Otherwise the problem is not actually difficult.
  %% TODO: Add an illustration to the problem.
\end{frame}

%%% TODO: Extra explanation of other data sets (include problems too!)

%% Hash table
%% O(1) for insert, search, delete (if hash map is good!)
%% No hashmap on STL, but java API has one. 
%% Usually MAP (O log n) is good enough

%%%% Extras: Direct addressing table, Heap
%%%% Future classes: Graphs, Trees (Fenwick tree, segment tree), Tables

%% TODO: Graph description on Chapter 2 to be added to the Graph chapter
%% Union-find also to add to graph chapter

%%%%%%%%%%%%%%%%%%%% BITSET %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Bitmasks}
\subsection{Bitmasks}

\begin{frame}[singleframe,fragile]
  \frametitle{Using Bitmasks}
  {\smaller
  A \structure{bitmask} is a lightweight version of a
  \structure{bitset}. You can use an unsigned integer or an unsigned
  long directly as a proxy for a bitset.

  \begin{block}{}
\begin{verbatim}
#include <iostream>

using namespace std;

int main() {
    unsigned long bb = 3432;
    unsigned long kk = 14;
    cout << (bb & kk) << endl;
    cout << (bb << 3) << endl;
}
\end{verbatim}
  \end{block}

  In a programming contest, they are very useful for quickly
  manipulating sets (specially if you need to modify a large number of
  members at the same time).
  }
\end{frame}

\begin{frame}[fragile,singleslide]
  \frametitle{When to use bitmasks} 
  
  {\smaller In programming challenges, bitmasks are useful for quickly
    manipulating sets of items. Specially if you need to modify
    multiple sets at the same time.  

    \begin{block}{}
      $S = 34 = 100010$\\
      \medskip
      Can be seen as a set with elements 1 and 5 present.\\ 
      The index increase with the digit significance.
    \end{block}
    
    \bigskip

    In regular programming, bitmasks are often used to quickly
    set/check flags or options.
    
    \begin{block}{Bitmasks in regular programming}
      \begin{itemize}
      \item Parameter setting/testing
\begin{verbatim}
Gdx.gl.glClear( GL20.GL_COLOR_BUFFER_BIT | 
                GL20.GL_DEPTH_BUFFER_BIT );
\end{verbatim}
      \item Collision/Filtering in computer graphics
\begin{verbatim}
if( isFilled(sprite1Pixel) && isFilled(sprite2Pixel))
    return true;
\end{verbatim}
      \end{itemize}
    \end{block}
  }
\end{frame}

\begin{frame}[singleslide,fragile]
  \frametitle{Binary Operatons on Bitmasks (2)}
{\smaller

  \begin{itemize}
  \item Multiply/Divide an integer by two :: shift bits left, right
\begin{verbatim}
S          = 34       =  100010
S = S << 1 = S*2 = 68 = 1000100
S = S >> 2 = S/4 = 17 =   10001
S = S >> 1 = S/2 =  8 =    1000
\end{verbatim}
\item To check if the ith item is on the set, use bitwise AND
  operation, (T = S \& (1 << j)) and test if the result is not zero.
\begin{verbatim}
S          = 34       =  100010
j = 3, 1 << j         =  001000
i = 1, 1 << 1         =  000010
                         ------
Tj= S & ( 1 << j)     =  000000  = 0 # 3 is not set
Ti= S & ( 1 << i)     =  000010 != 0 # 1 is set
\end{verbatim}

  \end{itemize}

}
\end{frame}

\begin{frame}[fragile,singleslide]
  \frametitle{Binary Operations on Bitmasks (2)}
  {\smaller
  \begin{itemize}
  \item To set/turn on the jth item, use bitwise OR operation S |= (1 << j)
\begin{verbatim}
S          = 34       =  100010
j = 3, 1 << j         =  001000
                         ------ OR (S |= 1 << j)
S          = 42       =  101010
\end{verbatim}
\item To set/turn off the jth item, use bitwise AND operation S \&= ~(1 << j)
\begin{verbatim}
S          = 50       =  110010
j = (1<<5)|(1<<3)     =  101000 # unset items 5,3 
~j                    =  010111
                         ------
S &= ~(j)             =  010010 # 18
\end{verbatim}
  \end{itemize}

  }
\end{frame}

\begin{frame}[fragile,singleslide]
  \frametitle{Have some code with the previous examples!}
  {\smaller
\begin{verbatim}
#include <iostream>
using namespace std;

int main() {
    unsigned int S = 34;    
    cout << (S<<1) << endl;
    cout << ((S<<1)>>2) << endl;
    cout << (((S<<1)>>2)>>1) << endl << endl;    
    cout << (S & (1 << 3)) << endl;
    cout << (S & (1 << 1)) << endl << endl;    
    cout << (S | (1 << 3)) << endl;    
    S = 50;
    cout << (S & ~((1 << 5)|(1<<3))) << endl;
}
\end{verbatim}

  }

\end{frame}


%\begin{frame}
%  \frametitle{Output on Bitmasks}
%  Bitmasks to integer
%  Bitmasks to bits
%\end{frame}


\begin{frame}[fragile,singleframe]
  \frametitle{Bitsets}
  {\smaller

  Bitsets can also be used in place of integer bitmasks:

  \begin{block}{}
\begin{verbatim}
#include <bitset>
#include <iostream>

using namespace std;

int main() {
    bitset<12> b(3432);
    cout << "3432 in binary is " << b << endl;
    
    bitset<12> k(14);
    cout << (b & k) << endl;
    cout << (b<<3) << endl;
}
\end{verbatim}
  \end{block}
  }
\end{frame}


\begin{frame}
  \frametitle{Bitsets and Bitmasks}

  {\smaller
  Most bitmask operations are also supported by bitsets. (But you can't mix them!)

  \begin{itemize}
  \item All binary operations are supported;
  \item Bitsets are of fixed size, but not limited to 32 and 64 bits.
  \item Bitset standard output is a bit string, not a decimal (but
    outputing a decimal is possible);
  \item But maybe bitmasks are more efficient?
  \end{itemize}
  
  More information about bitmasks 

  \url{http://www.drdobbs.com/the-standard-librarian-bitsets-and-bit-v/184401382}
  }
\end{frame}

\subsection{Conclusion}
\begin{frame}
  \frametitle{Conclusion}

  Today we talked about:
  
  \begin{itemize}
  \item Searching using standard tools: Binary search, Best N search;
  \item Tree data structures for efficient searching;
  \item More about Bitmasks/Bitsets
  \end{itemize}
  
  Thanks for your time!
\end{frame}

%\subsection{Conclusion Monday}

%% Take from book
%\begin{frame}
%\end{frame}


\end{document}
