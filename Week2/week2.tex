\documentclass{beamer}
\input{../tools/beamerpreamble.tex}

\title[GB21802]{GB21802 - Programming Challenges}
\subtitle[]{Week 2 - Problem Solving Paradigms (Search)}
\author[Claus Aranha]{Claus Aranha\\{\footnotesize caranha@cs.tsukuba.ac.jp}}
\institute{College of Information Science}
\date{2015-04-22,25\\{\tiny Last updated \today}}

\begin{document}

\section{Introduction}
\subsection{Title}
\begin{frame}
\maketitle
\end{frame}

\subsection{Notes and Warnings}

\begin{frame}
  \frametitle{Last Week Results}
\end{frame}

\begin{frame}
  \frametitle{Special Notes}
  None this time!
\end{frame}

\section{Search}

\subsection{Definitions}
\begin{frame}
  \frametitle{What is Search?}
  What is search in a common sense of the word 
  (finding your cellphone in your home)
\end{frame}

\begin{frame}
  \frametitle{What is Search? (In a programming challenge)}
  - a way to think about the problem and the solution

  - There are answer. We can classify the answers into correct and incorrect
  - We can also, usually, order the answers (both correct and incorrect)
\end{frame}

\begin{frame}
  \frametitle{Now you are thinking with search spaces}
  Thinking of problems as search problems allows us to define 
  some strategies about how to analyse each of the possible searches.

  Main question: In what order should we analyse the possible answers?
\end{frame}

\begin{frame}
  \frametitle{Search Paradigm}
  Complete Search/Brute Force
  Divide and Conquer
  Greedy Approach
  Dynamic Programming (Next week!)
\end{frame}

\begin{frame}
  \frametitle{Search Space/Search Structure}
  Most problems in programming challenges can be defined
  as search problems

  But sometimes that is not the optimal way.

  And sometimes more than one definition is possible!
\end{frame}


\subsection{Theoretical Example}

\begin{frame}
  \frametitle{Theoretical Example}
%% 
% Book example: Array A containing n < 10K integers smaller than
% 100K: example: A = {10,7,3,5,8,2,9}, n = 7

% Find Largest and smallest element of A
% Find kth smallest element of A
% Find largest gap G such that x,y \in A and g = |x-y|
% Find the longest increasing subsequence of A
\end{frame}

\begin{frame}
  \frame{Solving it with Complete (brute) search}
  % 1- O(n)
  % 2- O(n^2) - repeate the search k times
  %    Order and search is O(nlogn), divide and conquer (9.29) is O(n)
  %    For small queries
  % 3- All possible pairs: O(n^2). Prove that g is composed of minimum and 
  %    maximum numbers, O(n) Greedy search.
  % 4- All possible subsequences: O(2^n). Dynamic programming O(n^2), greedy
  %    O(nlogk)
\end{frame}

\section{Complete Search}
\subsection{Definition}
% List and test "all" solutions (Brute force, backtracking)
% Of course, you can prune: throw away solutions as you go

\subsection{True Example 1}
% Insert Division example here
%%% Problem Example: Loops:  UVA 725 - Division
% Problem Description
%% Search solution: iteractive loops (try all possible fghij, and test if all are different)
%% Simple: All fghij from 0 to 99999. Or maybe All from 10000 to 99999
%% Or we can prune this a bit
%% Max: 01234 to 98765
%% Max: 98765/N
% Loop ideas, we can prune the loop using continue, or break. 

\subsection{Considerations}
%% What is a complete search: 
%% List all solutions, and check one by one
%% If bug-free, should ALWAYS be correct (checks ALL solutions!)
%% Of course, in many cases, it takes too long.

% Should be the first solution considered. KISS
% Should be used if the problem is too small that a better solution is overkill
% Should be used if you really have no other ideas
% PRUNE PRUNE PRUNE (but beware of WA)

% Sometimes, using a (simple) complete search on some 
% example inputs allow you to get an intuition for the problem



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Example 2: Multiple Loops + Pruning
%% UVA 11565 - Simple equations
% Find X, Y, Z that obey: x+y+z=A,x*y*z=B,x^2+y^2+z^2=C, with minimal X
% When we first look at it, we might think that we need to solve the equations
% But on a second look, we can treat this as a search problem.

% First take x^2+y^2+z^2 = C. Since maximum C is 10000, and X,Y,Z must be 
% different, the maximum range of x is -100 to 100. The Reasoning goes for 
% Y and Z. With this we can do a triple loop with about 8M operations.

\begin{frame}[fragile,singleslide]
  \frametitle{11565 -- Three layered solution}
{\smaller
\begin{verbatim}
bool sol = false; int x,y,z;
for (x = -100; x <= 100 && !sol; x++)
  for (y = -100; y <= 100 && !sol; y++)
    for (z = -100; z <= 100 && !sol; z++)
      if (y != x && z != x && z != y &&
          x + y + z == A && x * y * z == B && x*x + y*y + z*z == C) {
             if (!sol) printf("%d %d %d\n", x,y,z);
             sol = true;
          }
\end{verbatim}
}
\end{frame}

%% Super hard version on 11571


%%% TIPs

% Biggest gambling in using a complete Search solution is: 
% Will it pass the time limit? If you calculate your 
% program to be ``borderline'', it might be worth it
% finding the critical part of the code and trying 
% to Optimize it.

%% TIP 1 - Filtering Vs Generating
% Filter programs examine all solutions and remove incorrect ones
% Generating programs gradually build solutions and prune invalid
% partial solutions.

% Filters are usually iteratively (for) while generators are often recursive.
% Filters are usually easier to code, but run slower.

%% TIP 2 - Prune Early
% Example, in the Nqueen problem, if we imagine a recursive solution that 
% places 1 queen per column, we can prune rows, columns and DIAGONALS
% (Also remember to mark impossible places when you enter recursion, and unmark
% when you leave, using bitmasks)
%%% 2.A - Finding simmetries can help, but it is often not worth the troube.

%% Tip 3 - Solving the probl;em backwards
% Or, in other words, solve the problem from a less obvious angle
% UVA 10360 - Rat Attack
% Obvious approach: Check each of the 1024^2 cells, and choose the biggest one.
% 1024^2 x 50^2 = 2621M = TLE
% Backwards approach: Make a 1024 x 1024 matrix of ``killed''. For each rat population,
% Add its value to each cell that the bomb D can reach.
% n * d^2 = 20000*2500 = 50M + 1024*1024

%% Tip 4 - Pre-Computation
% Sometimes it is possible to generate tables of partial solutions,
% Load them as data in your code, to accelerate computation (at the expense of memory)
% The programming cost of this might be high, unless you output your pre-computation
% In a code-friendly way.

%% Tip 5 - Optimizing the source code
% Iteration is usually faster than recursion
% Operating on built-in data types is usually faster than operations on arrays/vectors
% Many other tips: Just beware of the tradeoff: Time optimization vs Programmer Optimization


%%%% 3.3 Divide and conquer

\section{D\&C}
\subsection{Divide and Conquer}
\begin{frame}
  \frametitle{Divide and Conquer}

  D\&C is a problem-solving paradigm in which a problem is made
  simpler by 'dividing' it into smaller parts.

  \begin{itemize}
  \item Divide the original problem into sub-problems;
  \item Find (sub)-solutions for each sub-problems;
  \item Combine sub-solutions to get a complete solution;
  \end{itemize}

  \begin{block}{Examples}
    Quick Sort, Binary Search, etc...
  \end{block}
\end{frame}

%% Canonical -- 
% searching an item in a static sorted array, check the middle, then take 
% the appropriate half O(logn). 

%%% Binary Search on Uncommon Data Structures
%% Example: Parents in a tree: Find the parent of node V that has value over P
% which is closest to the root. Q <= 20K, N <= 80K
%% Naive approach: For each note, search all parents. Worst case is QN (TLE)
%% Divide and conquer approach: Take each path from the root, and solve all
% Queries for each root, using binary search == O(QlogN)

%%% Bisection Method
% You have to pay V dollars, with a monthly D payment, in M months, %i interest
% If we fix m, v and i, what is the minimal d? (with 2 decimal cases)

% Example: d = 576.19, m = 2, v = 1000, i = 0.1
% After one Month, debt = 1000 x 1.1 - 576.19 = 523.81
% After two Months, debt = 523.81 x 1.1 - 576.19 = 0

% Bisection method: Choose the range [a..b], (ex: 0.01 1100.00)
% Do a binary search for d in this range

% a & b & d & status: f(d,m,v,i) & action: \\
% 0.01 & 1100.00 & 550.005 & undershoot by 54.9895 & increase d\\
% 550.005 & 1100.00 & 825.0025 & overshoot by 522.50525 & decrease d\\
% 550.005 & 825.0025 & 687.50375 & overshoot by 233.757875 & decrease d\\
% 550.005 & 687.50375 & 681.754375 & overshoot by 89.384187 & decrease d\\
% 550.005 & 618.754375 & 584.379688 & overshoot by 17.197344 & decrease d\\
% 550.005 & 584.379688 & 567.192344 & undershoot by 18.896078 & increase d\\
% 567.192344 & 584.379688 & 575.786016 & undershoot by 0.849366 & increase d\\
% ... & ... & ... & a few iterations later ... & ...\\
% ... & ... & 576.190476 & stop; error is now less than e & answer = 576.19\\

% Total number of iterations os O(log_2((b-a)/e))
% UVA - 11936 - Through the desert - uses this logic

%%%% 3.4 Greedy 
\section{Greedy}
\subsection{Greedy}
\begin{frame}
  \frametitle{Greedy}

% An algorithm is said to be greedy if it makes the locally optimal choice
% at each step, with the hope of eventually reaching the global optimal.

% For greedy to work, a problem must show two properties:
% 1- It has optimal sub-structures (Optimal solution of the problem
%    contains optimal solutions for the sub-problems)
% 2- It has the greedy property: Making locally optimal choices will lead 
%    ``eventually'' to the optimal solution (difficult to prove!)

\end{frame}

\begin{frame}
  \frametitle{Greedy Example 1}
  Coin Change:

  Given a target value V and a list of coin sizes, what is the minimum number 
  of coins that we must use to represent V?

  Example: V = 42, Coins = 25, 10, 5, 1 (a One coin means we can always make any value)

  However, if V = 6, and coins = 4,3,1, the greedy algorithm does not
  reach an optimal solution.
\end{frame}

\begin{frame}
  \frametitle{Greedy Example 2}
  Load balancing: (UVA 410)

  You have C chambers, and S < 2C specimens. You need to decide where
  each specimen should go to minimize ``imbalance''.

  Insights:

  - A chamber with 1 individual is always better than a chamber with 0
  individuals.

  - Order of chambers does not matter.

  %%% Make people think for a while here.

  Greedy algorithm: Order the individuals by weight, and 
  put one in each chambers until the chambers are full, then add one
  in each chamber backwards.
\end{frame}

\begin{frame}
  \frametitle{Greedy Example 3 - Dragon of LooWater (11292)}
  List of knights (with heights) and dragons (with diameter). Find the 
  minimal height of knights that cut the heads of all dragons 
  (knights can only cut the heads of dragons when D <= H).

  Sort knights and dragons, and from smallest to biggest dragon, 
  match with the smallest knight possible to solve.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% State Space Search
% UVA 11212 Editing a Book
% You can cut pages (in order) and paste them to correct the order of the book
% Report number of steps required.
% Upper bound: k-1 (paragraphs in the wrong position) - not correct answer, examples
% Calculations on the number of states for the problem (No solution given in the slides)



\section{Problem Discussion}



\end{document}
