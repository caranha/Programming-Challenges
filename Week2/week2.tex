\documentclass{beamer}
\input{../tools/beamerpreamble.tex}

\title[GB21802]{GB21802 - Programming Challenges}
\subtitle[]{Week 2 - Problem Solving Paradigms (Search)}
\author[Claus Aranha]{Claus Aranha\\{\footnotesize caranha@cs.tsukuba.ac.jp}}
\institute{College of Information Science}
\date{2015-05-6,9\\{\tiny Last updated \today}}

\begin{document}

\section{Introduction}
\subsection{Title}
\begin{frame}
\maketitle
\end{frame}

\subsection{Notes and Warnings}

\begin{frame}
  \frametitle{Last Week Results}
  {\smaller
    \begin{columns}[T]
      \column{0.5\textwidth}
      \begin{block}{Week 1}
        Problems Solved\\
        \begin{itemize}
        \item Division Of Nlogonia: 28/28
        \item Cancer Or Scorpio: 24/27
        \item 3n+1: 25/25
        \item Request for Proposal: 19/22
        \end{itemize}

        \medskip

        Manaba Submission: 29 Students
      \end{block}
      \column{0.5\textwidth}
      \begin{block}{Week 2}
        Problems Solved\\
        \begin{itemize}
          \item Jolly Jumpers: 26/26
          \item Army Buddies: 15/21
          \item Rotated Square: 17/17
          \item File Fragmentation: 4/5
          \item Contest Scoreboard: 10/11
          \item Multitasking: 3/5
          \item Jolibee Tournament: 7/7
        \end{itemize}

        \medskip

        Manaba Submission: 25 students
      \end{block}
    \end{columns}
  }

  \begin{center}
    Don't Give Up!
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Special Notes}
  \begin{block}{If the UVA Judge is offline}
    Sometimes the UVA Judge gets overloaded. If this happens near the
    deadline, send your programs to MANABA before the UVA
    deadline. Re-send your programs to UVA as soon as it becomes
    available again.
  \end{block}
  \begin{block}{If uDebug result is different from UVA result}
    uDebug is a volunteer service. Although it is very useful, its
    correctness is not guaranteed. If you see a result that indicates
    that uDebug is wrong, contact the maintainers of that site, they
    will be grateful for the report.
  \end{block}

  Always try to submit programs early!
\end{frame}

\begin{frame}
  \frametitle{Quick Review of Last Week}
  \begin{itemize}
  \item \structure{Linear Arrays} (unidimensional and bidimensional) are 
    KISS data structures;
    \begin{itemize}
    \item A lot of problems can be solved by iterating on arrays
    \item Always allocate a bit more than you need.
    \end{itemize}

    \medskip

  \item \structure{Bitmasks} are quick and efficient ways to store sets of
    True/False values;

    \medskip
    
  \item \structure{Tree data structures} can search very efficiently
    \begin{itemize}
    \item Instead of implementing your own, learn to use the
      structures available from the library.
    \end{itemize}
  \end{itemize}
\end{frame}

\section{Search}

\subsection{Definitions}
\begin{frame}
  \frametitle{Topic for this week: Search}

  \begin{block}{What is Search}
    In day to day life, we say we are \structure{searching} for
    something when we are trying to find where this something is
    located.

    \begin{itemize}
    \item Keys of your bycicle;
    \item Your wallet;
    \item Your cellphone;
    \end{itemize}

    When searching, we think of our \structure{Goal} (the thing we are
    searching), and the \structure{search space} (the number of places
    where the thing could be hidden)
    
  \end{block}
  
  {\smaller
  \hfill \emph{The thing you search is always in the last place you look}\\
  \hfill (\emph{By definition!})}
\end{frame}

\begin{frame}
  \frametitle{What is a ``Search Problem''?}
  {\small
    
    We call a problem a search problem, if we can describe the problem
    as checking multiple \emph{answers} in order to find one or more
    \emph{solutions}.

    \medskip

    \begin{itemize}
    \item Answers to a search problem could be \structure{correct} or \alert{incorrect};
    \item Answers can also possibly have higher or lower \structure{scores};
    \item We can \structure{sort} the answers by score, or by some other criteria;
    \end{itemize}

    \bigskip

    Many problems in programming challenges can be described as search
    problems! (even if sometimes there are better ways to describe
    them)
  }
\end{frame}

\begin{frame}
  \frametitle{Sample Search Problems}
  \begin{block}{Request For Proposal (Week 1)}  
    You are given a set of proposals with the number of satisfied
    requirements, and the total cost. \alert{Find} the proposal with
    the highest number of requirements, and the lowest total cost.

    \bigskip

    \structure{Search Space:} The set of proposals in the input.
  \end{block}

  \begin{block}{File Fragmentation (Week 2)}
    You are given a set of binary fragments. \alert{Find} a binary
    value that match all existing fragments.

    \bigskip

    \structure{Search Space:} The set of all binary values with size $< n$
  \end{block}

\end{frame}


\begin{frame}
  \frametitle{Now you are thinking with search spaces}

  When we define a problem as a search problem, we can use strategies
  based on organizing the search space, and systematically examining
  each solution contained in it.

  \bigskip

  Questions about the algorithm:
  \begin{itemize}
  \item How is the search space represented?
  \item How are the solutions ordered?
  \item In what order are the solutions tested?
  \item How many solutions are tested?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Thinking with search spaces: Request for Proposal}
  \begin{itemize}
  \item \structure{How is the search space represented?}\\
    For each proposal, the number of requirements and the cost are stored.
  \item \structure{How are the solutions ordered?}\\
    The array of proposals is ordered by highest number of requirements and lowest cost.
  \item \structure{In what order are the solutions tested?}\\
    Highest item in the array of proposals are checked first.
  \item \structure{How many solutions are tested?}\\
    Only the first item is returned.
  \end{itemize}  

  \bigskip

  Of course, for many problems there is more than one way to fill this
  pattern.
\end{frame}

\begin{frame}
  \frametitle{Search Paradigms}
  These are some common approaches for search problems:
  
  \begin{itemize}
    \item Complete Search/Brute Force;
    \item Divide and Conquer;
    \item Greedy Approach;
    \item Dynamic Programming (Next week!)
  \end{itemize}

  \bigskip

  As we said before, some problems can use multiple approaches (but
  not all of them are equally good!)
\end{frame}

\subsection{Examples}

\begin{frame}
  \frametitle{Theoretical Example (1)}

  \begin{block}{Search Space}
    You have an array $A$ of $n$ integers ($n < 10K$), where the value
    of each integer $a_i$ is ($0 \leq a_i \leq 100K$).
  \end{block}
  
  \bigskip

  Imagine the following problems:
  \begin{itemize}
  \item Find the Largest and the smallest element of $A$;
  \item Find the $k^{th}$ smallest element of $A$;
  \item Find the largest gap $G$ such that $x,y \in A$ and $G = |x-y|$;
  \item Find the longest increasing subsequence of A;
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Theoretical Example (2)} 

  {\smaller
  How costly would be to search the solutions for each of the four
  problems described?

  \bigskip
  
  \begin{itemize}
  \item Find the Largest and smallest element of $A$: O(n) - single
    pass, and we cannot really go faster than this.
  \item Find the $k^{th}$ smallest elements of $A$:
    \begin{itemize}
    \item Repeat the search k times: $O(n^2)$ in the worst case;
    \item Order the number and search: $O(n\text{log}n)$
    \end{itemize}
  \item Fing the largest gap:
    \begin{itemize}
    \item Try all possible pairs: $O(n^2)$
    \item Greedy: Find the smallest and largest numbers $O(n)$ (you
      have to prove this works)
    \end{itemize}
  \item Longest increasing subsequence:
    \begin{itemize}
    \item Test all possible subsequences (brute force): $O(2^n)$
    \item Dynamic programming: $O(n^2)$
    \item Greedy search: $O(n\text{log}k)$ -- can you prove this?
    \end{itemize}
  \end{itemize}  
  }
\end{frame}

\section{Complete Search}
\subsection{Definition}
\begin{frame}
  \frametitle{Complete Search/Brute Force (1)}

  \structure{Complete Search} algorithms are expected to test all (or
  almost all) solutions.

  \bigskip

  \begin{exampleblock}{}
  Complete Search are usually called ``Brute Force''. But because they
  are often the best way to solve a problem, we use a nicer name here.
  \end{exampleblock}
\end{frame}


\begin{frame}
  \frametitle{Complete Search/Brute Force (2)}

  Structure of a Complete Search:

  \bigskip

  \begin{itemize}
  \item Test all existing solutions\\
    Usually achieved through either for loops or recursive calls;

    \bigskip

  \item Prune, Prune, Prune\\
    Remove bad solutions (or bad sets of solutions) as you go, by 
    ``breaking'' early form loops, or setting good ending conditions 
    to the recursive calls.
  \end{itemize}
  
\end{frame}

\subsection{True Example 1}
\begin{frame}
  \frametitle{Complete Search Example: UVA 725 -- Division}
  \begin{block}{Problem Summary}
    Given an integer N, find all pairs of numbers $abcde$ and $fghij$ so that 
    $fghij/abcde = N$ and all 10 digits are different.

    \bigskip

    \structure{Example:} $N = 62$

    \medskip

    79546 / 01283 = 62\\
    94736 / 01528 = 62\\
  \end{block}

  \vfill
  
  Consider this problem for a bit before I show how to solve it using search.
\end{frame}

\begin{frame}[fragile,singleslide]
  \frametitle{Complete Search Example: UVA 725 -- Division}
  {\smaller
  \begin{block}{Full Search Solution:}
    A naive way to solve the problem is to test all $0 \leq x \leq
    99999$, calculate $y = x*n$, and test whether $x$ and $y$ have 
    all different digits.
  \end{block}

\begin{verbatim}
for (int x = 0; x < 99999; x++)
{
  y = x*n;
  digits = test(x,y);
  if (digits == 1<<10 - 1) printf("%0.5d/%0.5d=%d\n",y,x,N);
}

int digits(int x, int y)
{
  int used = (x < 10000);
  int tmp; 
  tmp = x; while (tmp) {used |= 1 << (tmp%10); tmp /= 10; }
  tmp = y; while (tmp) {used |= 1 << (tmp%10); tmp /= 10; }
  return used;
}
\end{verbatim}
  
  }
\end{frame}

\begin{frame}
  \frametitle{Complete Search Example: UVA 725 -- Division}
  Pruning the complete loop:

  \bigskip

  \begin{itemize}
  \item What is the absolute minimum and maximum for x? 01234:98765

    \bigskip

  \item Maximum for Y is also 98765, so the actual maximum for x is 
    $x < 98766/n$

    \bigskip

  \item Can we cut the digits test earlier?
  \end{itemize}
\end{frame}

\subsection{Considerations}

\begin{frame}
  \frametitle{Considerations about complete search}
  \begin{itemize}
  \item A bug-free complete search should ALWAYS be correct.\\
    \begin{itemize}
    \item A complete search tests all solutions, so it should always
      find the correct one;
    \item Of course, in many cases, checking all solutions takes too long;
    \end{itemize}

    \bigskip

  \item Complete Search should always be solution considered (KISS
    principle)
    \begin{itemize}
    \item If the problem is so small that a better solution is overkill;
    \item If you are running out of ideas, or take too many WAs;
    \item Prune, prune, prune!
    \end{itemize}
    
    \bigskip

  \item Sometimes, you can use a simple complete search on a hard
    problem to get an idea of what sort of result is expected.
    \begin{itemize}
    \item Use it to generate solutions for test cases in problems that
      generate TLEs.
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Example 2}

\begin{frame}
  \frametitle{Complete Search Example 2: Simple Equations}
  \begin{block}{Problem Summary -- UVA 11565}
    Find $x,y,z$ so that $x+y+z=A$, $x*y*z=B$, $x^2+y^2+C^2=C$, $1
    \leq A,B,C \leq 10000$.

    \bigskip
  \end{block}

  \vfill

  We need to test sets of x,y,z, but how do we set the limits for
  these values?
\end{frame}

% First take x^2+y^2+z^2 = C. Since maximum C is 10000, and X,Y,Z must be 
% different, the maximum range of x is -100 to 100. The Reasoning goes for 
% Y and Z. With this we can do a triple loop with about 8M operations.

\begin{frame}[fragile,singleslide]
  \frametitle{Example 2: Simple Equations -- initial pruning}

  \begin{block}{}
    Consider $x^2 + y^2 + x^2 = C$. Since $C \leq 10000$, the maximum
    range for $x,y,z$ must be $-100, 100$.
    
    \bigskip

    Therefore, here is the \structure{Complete Search Loop}    
  \end{block}

{\smaller
\begin{verbatim}
bool sol = false; int x,y,z;
for (x = -100; x <= 100 && !sol; x++)
  for (y = -100; y <= 100 && !sol; y++)
    for (z = -100; z <= 100 && !sol; z++)
      if (y != x && z != x && z != y &&
          x + y + z == A && x * y * z == B && x*x + y*y + z*z == C) {
             if (!sol) printf("%d %d %d\n", x,y,z);
             sol = true;
          }
\end{verbatim}

\begin{block}{}
  Can you think of other ways to prune the loop?

  
\end{block}
}
\end{frame}

\begin{frame}
  \frametitle{Example 2: Simple Equations -- more pruning}
  There are many other ways that we can prune the loop:

  \medskip

  \begin{itemize}
  \item We can change the range using the actual input values of $A,B,C$
  \item We only need one solution. We can break the loop once we find it.
  \item We can consider the other two equations, specially equation 2.
  \end{itemize}

  \vfill

  \begin{alertblock}{}
    This week's problem: ``Simple Equations -- Extreme!'' has a much
    higher range for $A,B,C$. You need a lot of pruning to avoid a TLE!
  \end{alertblock}
\end{frame}

\subsection{Complete search: TIPS}

\begin{frame}
  \frametitle{Complete Search: TIPS 1}
\end{frame}

%%% TIPs

% Biggest gambling in using a complete Search solution is: 
% Will it pass the time limit? If you calculate your 
% program to be ``borderline'', it might be worth it
% finding the critical part of the code and trying 
% to Optimize it.

%% TIP 1 - Filtering Vs Generating
% Filter programs examine all solutions and remove incorrect ones
% Generating programs gradually build solutions and prune invalid
% partial solutions.

% Filters are usually iteratively (for) while generators are often recursive.
% Filters are usually easier to code, but run slower.

%% TIP 2 - Prune Early
% Example, in the Nqueen problem, if we imagine a recursive solution that 
% places 1 queen per column, we can prune rows, columns and DIAGONALS
% (Also remember to mark impossible places when you enter recursion, and unmark
% when you leave, using bitmasks)
%%% 2.A - Finding simmetries can help, but it is often not worth the troube.

%% Tip 3 - Solving the probl;em backwards
% Or, in other words, solve the problem from a less obvious angle
% UVA 10360 - Rat Attack
% Obvious approach: Check each of the 1024^2 cells, and choose the biggest one.
% 1024^2 x 50^2 = 2621M = TLE
% Backwards approach: Make a 1024 x 1024 matrix of ``killed''. For each rat population,
% Add its value to each cell that the bomb D can reach.
% n * d^2 = 20000*2500 = 50M + 1024*1024

%% Tip 4 - Pre-Computation
% Sometimes it is possible to generate tables of partial solutions,
% Load them as data in your code, to accelerate computation (at the expense of memory)
% The programming cost of this might be high, unless you output your pre-computation
% In a code-friendly way.

%% Tip 5 - Optimizing the source code
% Iteration is usually faster than recursion
% Operating on built-in data types is usually faster than operations on arrays/vectors
% Many other tips: Just beware of the tradeoff: Time optimization vs Programmer Optimization


%%%% 3.3 Divide and conquer

\section{D\&C}
\subsection{Divide and Conquer}
\begin{frame}
  \frametitle{Divide and Conquer}

  D\&C is a problem-solving paradigm in which a problem is made
  simpler by 'dividing' it into smaller parts.

  \begin{itemize}
  \item Divide the original problem into sub-problems;
  \item Find (sub)-solutions for each sub-problems;
  \item Combine sub-solutions to get a complete solution;
  \end{itemize}

  \begin{block}{Examples}
    Quick Sort, Binary Search, etc...
  \end{block}
\end{frame}

%% Canonical -- 
% searching an item in a static sorted array, check the middle, then take 
% the appropriate half O(logn). 

%%% Binary Search on Uncommon Data Structures
%% Example: Parents in a tree: Find the parent of node V that has value over P
% which is closest to the root. Q <= 20K, N <= 80K
%% Naive approach: For each note, search all parents. Worst case is QN (TLE)
%% Divide and conquer approach: Take each path from the root, and solve all
% Queries for each root, using binary search == O(QlogN)

%%% Bisection Method
% You have to pay V dollars, with a monthly D payment, in M months, %i interest
% If we fix m, v and i, what is the minimal d? (with 2 decimal cases)

% Example: d = 576.19, m = 2, v = 1000, i = 0.1
% After one Month, debt = 1000 x 1.1 - 576.19 = 523.81
% After two Months, debt = 523.81 x 1.1 - 576.19 = 0

% Bisection method: Choose the range [a..b], (ex: 0.01 1100.00)
% Do a binary search for d in this range

% a & b & d & status: f(d,m,v,i) & action: \\
% 0.01 & 1100.00 & 550.005 & undershoot by 54.9895 & increase d\\
% 550.005 & 1100.00 & 825.0025 & overshoot by 522.50525 & decrease d\\
% 550.005 & 825.0025 & 687.50375 & overshoot by 233.757875 & decrease d\\
% 550.005 & 687.50375 & 681.754375 & overshoot by 89.384187 & decrease d\\
% 550.005 & 618.754375 & 584.379688 & overshoot by 17.197344 & decrease d\\
% 550.005 & 584.379688 & 567.192344 & undershoot by 18.896078 & increase d\\
% 567.192344 & 584.379688 & 575.786016 & undershoot by 0.849366 & increase d\\
% ... & ... & ... & a few iterations later ... & ...\\
% ... & ... & 576.190476 & stop; error is now less than e & answer = 576.19\\

% Total number of iterations os O(log_2((b-a)/e))
% UVA - 11936 - Through the desert - uses this logic

%%%% 3.4 Greedy 
\section{Greedy}
\subsection{Greedy}
\begin{frame}
  \frametitle{Greedy}

% An algorithm is said to be greedy if it makes the locally optimal choice
% at each step, with the hope of eventually reaching the global optimal.

% For greedy to work, a problem must show two properties:
% 1- It has optimal sub-structures (Optimal solution of the problem
%    contains optimal solutions for the sub-problems)
% 2- It has the greedy property: Making locally optimal choices will lead 
%    ``eventually'' to the optimal solution (difficult to prove!)

\end{frame}

\begin{frame}
  \frametitle{Greedy Example 1}
  Coin Change:

  Given a target value V and a list of coin sizes, what is the minimum number 
  of coins that we must use to represent V?

  Example: V = 42, Coins = 25, 10, 5, 1 (a One coin means we can always make any value)

  However, if V = 6, and coins = 4,3,1, the greedy algorithm does not
  reach an optimal solution.
\end{frame}

\begin{frame}
  \frametitle{Greedy Example 2}
  Load balancing: (UVA 410)

  You have C chambers, and S < 2C specimens. You need to decide where
  each specimen should go to minimize ``imbalance''.

  Insights:

  - A chamber with 1 individual is always better than a chamber with 0
  individuals.

  - Order of chambers does not matter.

  %%% Make people think for a while here.

  Greedy algorithm: Order the individuals by weight, and 
  put one in each chambers until the chambers are full, then add one
  in each chamber backwards.
\end{frame}

\begin{frame}
  \frametitle{Greedy Example 3 - Dragon of LooWater (11292)}
  List of knights (with heights) and dragons (with diameter). Find the 
  minimal height of knights that cut the heads of all dragons 
  (knights can only cut the heads of dragons when D <= H).

  Sort knights and dragons, and from smallest to biggest dragon, 
  match with the smallest knight possible to solve.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% State Space Search
% UVA 11212 Editing a Book
% You can cut pages (in order) and paste them to correct the order of the book
% Report number of steps required.
% Upper bound: k-1 (paragraphs in the wrong position) - not correct answer, examples
% Calculations on the number of states for the problem (No solution given in the slides)



\section{Week's Problems}
\subsection{Problem Discussion}
%% TODO: Include problemlist
\begin{frame}
  \frametitle{Problem Discussion}
  \begin{columns}
    \column{0.5\textwidth}
    \begin{itemize}
    \item Division
    \item Social Constraints
    \item Simple Equations - EXTREME!!
    \item Bars
    \item Rat Attack
    \end{itemize}
    \column{0.5\textwidth}
    \begin{itemize}
    \item Little Bishops
    \item Water Gate Management
    \item Through the Desert
    \item Dragon of Loowater
    \item Shoemaker's Problem
    \end{itemize}
  \end{columns}
\end{frame}


\section{Extra}
%% TODO: Complete this
\subsection{Search Research}
\begin{frame}
  \frametitle{Search Algorithms are an important area of research}
  Heuristics
\end{frame}

\end{document}
